<?php

// Generated by Haxe 3.4.4
class haxe_Int64Helper {
	public function __construct(){}
	static function parseString($sParam) {
		$x = new haxe__Int64____Int64(0, 10);
		$this1 = $x;
		$base = $this1;
		$x1 = new haxe__Int64____Int64(0, 0);
		$this2 = $x1;
		$current = $this2;
		$x2 = new haxe__Int64____Int64(0, 1);
		$this3 = $x2;
		$multiplier = $this3;
		$sIsNegative = false;
		$s = trim($sParam);
		if(_hx_char_at($s, 0) === "-") {
			$sIsNegative = true;
			$s = _hx_substring($s, 1, strlen($s));
		}
		$len = strlen($s);
		{
			$_g1 = 0;
			$_g = $len;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$digitInt = _hx_char_code_at($s, $len - 1 - $i) - 48;
				$tmp = null;
				if($digitInt >= 0) {
					$tmp = $digitInt > 9;
				} else {
					$tmp = true;
				}
				if($tmp) {
					throw new HException("NumberFormatError");
				}
				$x3 = new haxe__Int64____Int64($digitInt >> 31, $digitInt);
				$this4 = $x3;
				$digit = $this4;
				if($sIsNegative) {
					$mask = 65535;
					$al = $multiplier->low & $mask;
					$ah = _hx_shift_right($multiplier->low, 16);
					$bl = $digit->low & $mask;
					$bh = _hx_shift_right($digit->low, 16);
					$p00 = haxe__Int32_Int32_Impl_::mul($al, $bl);
					$p10 = haxe__Int32_Int32_Impl_::mul($ah, $bl);
					$p01 = haxe__Int32_Int32_Impl_::mul($al, $bh);
					$p11 = haxe__Int32_Int32_Impl_::mul($ah, $bh);
					$low = $p00;
					$high = ($p11 + (_hx_shift_right($p01, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p10, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$p01 = $p01 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low = $low + $p01 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p01) < 0) {
						$high = $high + 1;
						$ret = $high - 1;
						$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret);
					}
					$p10 = $p10 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low = $low + $p10 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p10) < 0) {
						$high = $high + 1;
						$ret1 = $high - 1;
						$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret1);
					}
					$a = haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high);
					$b = $a + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low);
					$high = $high + ($b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$x4 = new haxe__Int64____Int64($high, $low);
					$this5 = $x4;
					$b1 = $this5;
					$high1 = $current->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low1 = $current->low - $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($current->low, $b1->low) < 0) {
						$high1 = $high1 - 1;
						$ret2 = $high1 + 1;
						$high1 = $high1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret2);
					}
					$x5 = new haxe__Int64____Int64($high1, $low1);
					$this6 = $x5;
					$current = $this6;
					if(!($current->high < 0)) {
						throw new HException("NumberFormatError: Underflow");
					}
					unset($x5,$x4,$this6,$this5,$p11,$p10,$p01,$p00,$mask,$low1,$low,$high1,$high,$bl,$bh,$b1,$b,$al,$ah,$a);
				} else {
					$mask1 = 65535;
					$al1 = $multiplier->low & $mask1;
					$ah1 = _hx_shift_right($multiplier->low, 16);
					$bl1 = $digit->low & $mask1;
					$bh1 = _hx_shift_right($digit->low, 16);
					$p001 = haxe__Int32_Int32_Impl_::mul($al1, $bl1);
					$p101 = haxe__Int32_Int32_Impl_::mul($ah1, $bl1);
					$p011 = haxe__Int32_Int32_Impl_::mul($al1, $bh1);
					$p111 = haxe__Int32_Int32_Impl_::mul($ah1, $bh1);
					$low2 = $p001;
					$high2 = ($p111 + (_hx_shift_right($p011, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p101, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$p011 = $p011 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $low2 + $p011 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p011) < 0) {
						$high2 = $high2 + 1;
						$ret3 = $high2 - 1;
						$high2 = $high2 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret3);
					}
					$p101 = $p101 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $low2 + $p101 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p101) < 0) {
						$high2 = $high2 + 1;
						$ret4 = $high2 - 1;
						$high2 = $high2 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret4);
					}
					$a1 = haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high);
					$b2 = $a1 + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low);
					$high2 = $high2 + ($b2 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$x6 = new haxe__Int64____Int64($high2, $low2);
					$this7 = $x6;
					$b3 = $this7;
					$high3 = $current->high + $b3->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low3 = $current->low + $b3->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low3, $current->low) < 0) {
						$high3 = $high3 + 1;
						$ret5 = $high3 - 1;
						$high3 = $high3 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($ret5);
					}
					$x7 = new haxe__Int64____Int64($high3, $low3);
					$this8 = $x7;
					$current = $this8;
					if($current->high < 0) {
						throw new HException("NumberFormatError: Overflow");
					}
					unset($x7,$x6,$this8,$this7,$p111,$p101,$p011,$p001,$mask1,$low3,$low2,$high3,$high2,$bl1,$bh1,$b3,$b2,$al1,$ah1,$a1);
				}
				$mask2 = 65535;
				$al2 = $multiplier->low & $mask2;
				$ah2 = _hx_shift_right($multiplier->low, 16);
				$bl2 = $base->low & $mask2;
				$bh2 = _hx_shift_right($base->low, 16);
				$p002 = haxe__Int32_Int32_Impl_::mul($al2, $bl2);
				$p102 = haxe__Int32_Int32_Impl_::mul($ah2, $bl2);
				$p012 = haxe__Int32_Int32_Impl_::mul($al2, $bh2);
				$p112 = haxe__Int32_Int32_Impl_::mul($ah2, $bh2);
				$low4 = $p002;
				$high4 = ($p112 + (_hx_shift_right($p012, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p102, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$p012 = $p012 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $low4 + $p012 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p012) < 0) {
					$high4 = $high4 + 1;
					$ret6 = $high4 - 1;
					$high4 = $high4 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret6);
				}
				$p102 = $p102 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $low4 + $p102 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p102) < 0) {
					$high4 = $high4 + 1;
					$ret7 = $high4 - 1;
					$high4 = $high4 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret7);
				}
				$a2 = haxe__Int32_Int32_Impl_::mul($multiplier->low, $base->high);
				$b4 = $a2 + haxe__Int32_Int32_Impl_::mul($multiplier->high, $base->low);
				$high4 = $high4 + ($b4 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$x8 = new haxe__Int64____Int64($high4, $low4);
				$this9 = $x8;
				$multiplier = $this9;
				unset($x8,$x3,$tmp,$this9,$this4,$p112,$p102,$p012,$p002,$mask2,$low4,$i,$high4,$digitInt,$digit,$bl2,$bh2,$b4,$al2,$ah2,$a2);
			}
		}
		return $current;
	}
	static function fromFloat($f) {
		$tmp = null;
		if(!Math::isNaN($f)) {
			$tmp = !Math::isFinite($f);
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException("Number is NaN or Infinite");
		}
		$noFractions = $f - _hx_mod($f, 1);
		if($noFractions > 9007199254740991) {
			throw new HException("Conversion overflow");
		}
		if($noFractions < -9007199254740991) {
			throw new HException("Conversion underflow");
		}
		$x = new haxe__Int64____Int64(0, 0);
		$this1 = $x;
		$result = $this1;
		$neg = $noFractions < 0;
		$rest = null;
		if($neg) {
			$rest = -$noFractions;
		} else {
			$rest = $noFractions;
		}
		$i = 0;
		while($rest >= 1) {
			$curr = _hx_mod($rest, 2);
			$rest = $rest / 2;
			if($curr >= 1) {
				$x1 = new haxe__Int64____Int64(0, 1);
				$this2 = $x1;
				$a = $this2;
				$b = $i;
				$b = $b & 63;
				$b1 = null;
				if($b === 0) {
					$x2 = new haxe__Int64____Int64($a->high, $a->low);
					$this3 = $x2;
					$b1 = $this3;
					unset($x2,$this3);
				} else {
					if($b < 32) {
						$x3 = new haxe__Int64____Int64($a->high << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, 32 - $b), $a->low << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
						$this4 = $x3;
						$b1 = $this4;
						unset($x3,$this4);
					} else {
						$x4 = new haxe__Int64____Int64($a->low << $b - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
						$this5 = $x4;
						$b1 = $this5;
						unset($x4,$this5);
					}
				}
				$high = $result->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low = $result->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low, $result->low) < 0) {
					$high = $high + 1;
					$ret = $high - 1;
					$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret);
				}
				$x5 = new haxe__Int64____Int64($high, $low);
				$this6 = $x5;
				$result = $this6;
				unset($x5,$x1,$this6,$this2,$low,$high,$b1,$b,$a);
			}
			$i = $i + 1;
			unset($curr);
		}
		if($neg) {
			$high1 = ~$result->high;
			$low1 = -$result->low;
			if($low1 === 0) {
				$high1 = $high1 + 1;
				$ret1 = $high1 - 1;
				$high1 = $high1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x6 = new haxe__Int64____Int64($high1, $low1);
			$this7 = $x6;
			$result = $this7;
		}
		return $result;
	}
	function __toString() { return 'haxe.Int64Helper'; }
}
