<?php

// Generated by Haxe 3.4.4
class haxe_MainLoop {
	public function __construct(){}
	static $pending = null;
	static function add($f, $priority = null) {
		if($priority === null) {
			$priority = 0;
		}
		if($f === null) {
			throw new HException("Event function is null");
		}
		$e = new haxe_MainEvent($f, $priority);
		$head = haxe_MainLoop::$pending;
		if($head !== null) {
			$head->prev = $e;
		}
		$e->next = $head;
		haxe_MainLoop::$pending = $e;
		return $e;
	}
	static function sortEvents() {
		$list = haxe_MainLoop::$pending;
		if($list === null) {
			return;
		}
		$insize = 1;
		$nmerges = null;
		$psize = 0;
		$qsize = 0;
		$p = null;
		$q = null;
		$e = null;
		$tail = null;
		while(true) {
			$p = $list;
			$list = null;
			$tail = null;
			$nmerges = 0;
			while($p !== null) {
				$nmerges = $nmerges + 1;
				$q = $p;
				$psize = 0;
				{
					$_g1 = 0;
					$_g = $insize;
					while($_g1 < $_g) {
						$_g1 = $_g1 + 1;
						$i = $_g1 - 1;
						$psize = $psize + 1;
						$q = $q->next;
						if($q === null) {
							break;
						}
						unset($i);
					}
					unset($_g1,$_g);
				}
				$qsize = $insize;
				while(true) {
					$tmp = null;
					if($psize <= 0) {
						if($qsize > 0) {
							$tmp = $q !== null;
						} else {
							$tmp = false;
						}
					} else {
						$tmp = true;
					}
					if(!$tmp) {
						break;
					}
					if($psize === 0) {
						$e = $q;
						$q = $q->next;
						$qsize = $qsize - 1;
					} else {
						$tmp1 = null;
						$tmp2 = null;
						if($qsize !== 0) {
							$tmp2 = $q === null;
						} else {
							$tmp2 = true;
						}
						if(!$tmp2) {
							if($p->priority <= $q->priority) {
								if($p->priority === $q->priority) {
									$tmp1 = $p->nextRun <= $q->nextRun;
								} else {
									$tmp1 = false;
								}
							} else {
								$tmp1 = true;
							}
						} else {
							$tmp1 = true;
						}
						if($tmp1) {
							$e = $p;
							$p = $p->next;
							$psize = $psize - 1;
						} else {
							$e = $q;
							$q = $q->next;
							$qsize = $qsize - 1;
						}
						unset($tmp2,$tmp1);
					}
					if($tail !== null) {
						$tail->next = $e;
					} else {
						$list = $e;
					}
					$e->prev = $tail;
					$tail = $e;
					unset($tmp);
				}
				$p = $q;
			}
			$tail->next = null;
			if($nmerges <= 1) {
				break;
			}
			$insize = $insize * 2;
		}
		$list->prev = null;
		haxe_MainLoop::$pending = $list;
	}
	static function tick() {
		haxe_MainLoop::sortEvents();
		$e = haxe_MainLoop::$pending;
		$now = Sys::time();
		$wait = 1e9;
		while($e !== null) {
			$next = $e->next;
			$wt = $e->nextRun - $now;
			$tmp = null;
			if(!($e->nextRun < 0)) {
				$tmp = $wt <= 0;
			} else {
				$tmp = true;
			}
			if($tmp) {
				$wait = 0;
				if($e->f !== null) {
					$e->f();
				}
			} else {
				if($wait > $wt) {
					$wait = $wt;
				}
			}
			$e = $next;
			unset($wt,$tmp,$next);
		}
		return $wait;
	}
	function __toString() { return 'haxe.MainLoop'; }
}
