<?php

// Generated by Haxe 3.4.4
class haxe__Int64_Int64_Impl_ {
	public function __construct(){}
	static function _new($x) {
		$this1 = $x;
		return $this1;
	}
	static function copy($this1) {
		$x = new haxe__Int64____Int64($this1->high, $this1->low);
		$this2 = $x;
		return $this2;
	}
	static function make($high, $low) {
		$x = new haxe__Int64____Int64($high, $low);
		$this1 = $x;
		return $this1;
	}
	static function ofInt($x) {
		$x1 = new haxe__Int64____Int64($x >> 31, $x);
		$this1 = $x1;
		return $this1;
	}
	static function toInt($x) {
		if($x->high !== $x->low >> 31) {
			throw new HException("Overflow");
		}
		return $x->low;
	}
	static function is($val) {
		return Std::is($val, _hx_qtype("haxe._Int64.___Int64"));
	}
	static function getHigh($x) {
		return $x->high;
	}
	static function getLow($x) {
		return $x->low;
	}
	static function isNeg($x) {
		return $x->high < 0;
	}
	static function isZero($x) {
		$x1 = new haxe__Int64____Int64(0, 0);
		$this1 = $x1;
		$b = $this1;
		if($x->high === $b->high) {
			return $x->low === $b->low;
		} else {
			return false;
		}
	}
	static function compare($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		if($a->high < 0) {
			if($b->high < 0) {
				return $v;
			} else {
				return -1;
			}
		} else {
			if($b->high >= 0) {
				return $v;
			} else {
				return 1;
			}
		}
	}
	static function ucompare($a, $b) {
		$v = haxe__Int32_Int32_Impl_::ucompare($a->high, $b->high);
		if($v !== 0) {
			return $v;
		} else {
			return haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
	}
	static function toStr($x) {
		return haxe__Int64_Int64_Impl_::toString($x);
	}
	static function toString($this1) {
		$i = $this1;
		$x = new haxe__Int64____Int64(0, 0);
		$this2 = $x;
		$b = $this2;
		$tmp = null;
		if($i->high === $b->high) {
			$tmp = $i->low === $b->low;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return "0";
		}
		$str = "";
		$neg = false;
		if($i->high < 0) {
			$neg = true;
		}
		$x1 = new haxe__Int64____Int64(0, 10);
		$this3 = $x1;
		$ten = $this3;
		while(true) {
			$x2 = new haxe__Int64____Int64(0, 0);
			$this4 = $x2;
			$b1 = $this4;
			$tmp1 = null;
			if(!($i->high !== $b1->high)) {
				$tmp1 = $i->low !== $b1->low;
			} else {
				$tmp1 = true;
			}
			if(!$tmp1) {
				break;
			}
			$r = haxe__Int64_Int64_Impl_::divMod($i, $ten);
			if($r->modulus->high < 0) {
				$x3 = $r->modulus;
				$high = ~$x3->high;
				$low = -$x3->low;
				if($low === 0) {
					$high = $high + 1;
					$ret = $high - 1;
					$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret);
				}
				$x4 = new haxe__Int64____Int64($high, $low);
				$this5 = $x4;
				$str = _hx_string_rec($this5->low, "") . _hx_string_or_null($str);
				$x5 = $r->quotient;
				$high1 = ~$x5->high;
				$low1 = -$x5->low;
				if($low1 === 0) {
					$high1 = $high1 + 1;
					$ret1 = $high1 - 1;
					$high1 = $high1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret1);
				}
				$x6 = new haxe__Int64____Int64($high1, $low1);
				$this6 = $x6;
				$i = $this6;
				unset($x6,$x5,$x4,$x3,$this6,$this5,$low1,$low,$high1,$high);
			} else {
				$str = _hx_string_rec($r->modulus->low, "") . _hx_string_or_null($str);
				$i = $r->quotient;
			}
			unset($x2,$tmp1,$this4,$r,$b1);
		}
		if($neg) {
			$str = "-" . _hx_string_or_null($str);
		}
		return $str;
	}
	static function parseString($sParam) {
		return haxe_Int64Helper::parseString($sParam);
	}
	static function fromFloat($f) {
		return haxe_Int64Helper::fromFloat($f);
	}
	static function divMod($dividend, $divisor) {
		if($divisor->high === 0) {
			$_g = $divisor->low;
			switch($_g) {
			case 0:{
				throw new HException("divide by zero");
			}break;
			case 1:{
				$x = new haxe__Int64____Int64($dividend->high, $dividend->low);
				$this1 = $x;
				$x1 = new haxe__Int64____Int64(0, 0);
				$this2 = $x1;
				return _hx_anonymous(array("quotient" => $this1, "modulus" => $this2));
			}break;
			}
		}
		$divSign = (is_object($_t = $dividend->high < 0) && ($_t instanceof Enum) ? $_t != $divisor->high < 0 : !_hx_equal($_t, $divisor->high < 0));
		$modulus = null;
		if($dividend->high < 0) {
			$high = ~$dividend->high;
			$low = -$dividend->low;
			if($low === 0) {
				$high = $high + 1;
				$ret = $high - 1;
				$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x2 = new haxe__Int64____Int64($high, $low);
			$this3 = $x2;
			$modulus = $this3;
		} else {
			$x3 = new haxe__Int64____Int64($dividend->high, $dividend->low);
			$this4 = $x3;
			$modulus = $this4;
		}
		if($divisor->high < 0) {
			$high1 = ~$divisor->high;
			$low1 = -$divisor->low;
			if($low1 === 0) {
				$high1 = $high1 + 1;
				$ret1 = $high1 - 1;
				$high1 = $high1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x4 = new haxe__Int64____Int64($high1, $low1);
			$this5 = $x4;
			$divisor = $this5;
		} else {
			$divisor = $divisor;
		}
		$x5 = new haxe__Int64____Int64(0, 0);
		$this6 = $x5;
		$quotient = $this6;
		$x6 = new haxe__Int64____Int64(0, 1);
		$this7 = $x6;
		$mask = $this7;
		while(!($divisor->high < 0)) {
			$v = haxe__Int32_Int32_Impl_::ucompare($divisor->high, $modulus->high);
			$cmp = null;
			if($v !== 0) {
				$cmp = $v;
			} else {
				$cmp = haxe__Int32_Int32_Impl_::ucompare($divisor->low, $modulus->low);
			}
			$b = 1;
			$b = $b & 63;
			if($b === 0) {
				$x7 = new haxe__Int64____Int64($divisor->high, $divisor->low);
				$this8 = $x7;
				$divisor = $this8;
				unset($x7,$this8);
			} else {
				if($b < 32) {
					$x8 = new haxe__Int64____Int64($divisor->high << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($divisor->low, 32 - $b), $divisor->low << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
					$this9 = $x8;
					$divisor = $this9;
					unset($x8,$this9);
				} else {
					$x9 = new haxe__Int64____Int64($divisor->low << $b - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
					$this10 = $x9;
					$divisor = $this10;
					unset($x9,$this10);
				}
			}
			$b1 = 1;
			$b1 = $b1 & 63;
			if($b1 === 0) {
				$x10 = new haxe__Int64____Int64($mask->high, $mask->low);
				$this11 = $x10;
				$mask = $this11;
				unset($x10,$this11);
			} else {
				if($b1 < 32) {
					$x11 = new haxe__Int64____Int64($mask->high << $b1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($mask->low, 32 - $b1), $mask->low << $b1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
					$this12 = $x11;
					$mask = $this12;
					unset($x11,$this12);
				} else {
					$x12 = new haxe__Int64____Int64($mask->low << $b1 - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
					$this13 = $x12;
					$mask = $this13;
					unset($x12,$this13);
				}
			}
			if($cmp >= 0) {
				break;
			}
			unset($v,$cmp,$b1,$b);
		}
		while(true) {
			$x13 = new haxe__Int64____Int64(0, 0);
			$this14 = $x13;
			$b2 = $this14;
			$tmp = null;
			if(!($mask->high !== $b2->high)) {
				$tmp = $mask->low !== $b2->low;
			} else {
				$tmp = true;
			}
			if(!$tmp) {
				break;
			}
			$v1 = haxe__Int32_Int32_Impl_::ucompare($modulus->high, $divisor->high);
			$tmp1 = null;
			if($v1 !== 0) {
				$tmp1 = $v1;
			} else {
				$tmp1 = haxe__Int32_Int32_Impl_::ucompare($modulus->low, $divisor->low);
			}
			if($tmp1 >= 0) {
				$x14 = new haxe__Int64____Int64($quotient->high | $mask->high, $quotient->low | $mask->low);
				$this15 = $x14;
				$quotient = $this15;
				$high2 = $modulus->high - $divisor->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low2 = $modulus->low - $divisor->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($modulus->low, $divisor->low) < 0) {
					$high2 = $high2 - 1;
					$ret2 = $high2 + 1;
					$high2 = $high2 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($ret2);
				}
				$x15 = new haxe__Int64____Int64($high2, $low2);
				$this16 = $x15;
				$modulus = $this16;
				unset($x15,$x14,$this16,$this15,$low2,$high2);
			}
			$b3 = 1;
			$b3 = $b3 & 63;
			if($b3 === 0) {
				$x16 = new haxe__Int64____Int64($mask->high, $mask->low);
				$this17 = $x16;
				$mask = $this17;
				unset($x16,$this17);
			} else {
				if($b3 < 32) {
					$x17 = new haxe__Int64____Int64(_hx_shift_right($mask->high, $b3), $mask->high << 32 - $b3 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($mask->low, $b3));
					$this18 = $x17;
					$mask = $this18;
					unset($x17,$this18);
				} else {
					$x18 = new haxe__Int64____Int64(0, _hx_shift_right($mask->high, $b3 - 32));
					$this19 = $x18;
					$mask = $this19;
					unset($x18,$this19);
				}
			}
			$b4 = 1;
			$b4 = $b4 & 63;
			if($b4 === 0) {
				$x19 = new haxe__Int64____Int64($divisor->high, $divisor->low);
				$this20 = $x19;
				$divisor = $this20;
				unset($x19,$this20);
			} else {
				if($b4 < 32) {
					$x20 = new haxe__Int64____Int64(_hx_shift_right($divisor->high, $b4), $divisor->high << 32 - $b4 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($divisor->low, $b4));
					$this21 = $x20;
					$divisor = $this21;
					unset($x20,$this21);
				} else {
					$x21 = new haxe__Int64____Int64(0, _hx_shift_right($divisor->high, $b4 - 32));
					$this22 = $x21;
					$divisor = $this22;
					unset($x21,$this22);
				}
			}
			unset($x13,$v1,$tmp1,$tmp,$this14,$b4,$b3,$b2);
		}
		if($divSign) {
			$high3 = ~$quotient->high;
			$low3 = -$quotient->low;
			if($low3 === 0) {
				$high3 = $high3 + 1;
				$ret3 = $high3 - 1;
				$high3 = $high3 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x22 = new haxe__Int64____Int64($high3, $low3);
			$this23 = $x22;
			$quotient = $this23;
		}
		if($dividend->high < 0) {
			$high4 = ~$modulus->high;
			$low4 = -$modulus->low;
			if($low4 === 0) {
				$high4 = $high4 + 1;
				$ret4 = $high4 - 1;
				$high4 = $high4 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x23 = new haxe__Int64____Int64($high4, $low4);
			$this24 = $x23;
			$modulus = $this24;
		}
		return _hx_anonymous(array("quotient" => $quotient, "modulus" => $modulus));
	}
	static function neg($x) {
		$high = ~$x->high;
		$low = -$x->low;
		if($low === 0) {
			$high = $high + 1;
			$ret = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x1 = new haxe__Int64____Int64($high, $low);
		$this1 = $x1;
		return $this1;
	}
	static function preIncrement($this1) {
		$x = new haxe__Int64____Int64($this1->high, $this1->low);
		$this2 = $x;
		$this1 = $this2;
		{
			$ret = $this1->low++;
			$this1->low = $this1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		if($this1->low === 0) {
			$ret1 = $this1->high++;
			$this1->high = $this1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		return $this1;
	}
	static function postIncrement($this1) {
		$ret = $this1;
		{
			$x = new haxe__Int64____Int64($this1->high, $this1->low);
			$this2 = $x;
			$this1 = $this2;
			{
				$ret1 = $this1->low++;
				$this1->low = $this1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			if($this1->low === 0) {
				$ret2 = $this1->high++;
				$this1->high = $this1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
		}
		return $ret;
	}
	static function preDecrement($this1) {
		$x = new haxe__Int64____Int64($this1->high, $this1->low);
		$this2 = $x;
		$this1 = $this2;
		if($this1->low === 0) {
			$ret = $this1->high--;
			$this1->high = $this1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		{
			$ret1 = $this1->low--;
			$this1->low = $this1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		return $this1;
	}
	static function postDecrement($this1) {
		$ret = $this1;
		{
			$x = new haxe__Int64____Int64($this1->high, $this1->low);
			$this2 = $x;
			$this1 = $this2;
			if($this1->low === 0) {
				$ret1 = $this1->high--;
				$this1->high = $this1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			{
				$ret2 = $this1->low--;
				$this1->low = $this1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			}
		}
		return $ret;
	}
	static function add($a, $b) {
		$high = $a->high + $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a->low + $b->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $a->low) < 0) {
			$high = $high + 1;
			$ret = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x = new haxe__Int64____Int64($high, $low);
		$this1 = $x;
		return $this1;
	}
	static function addInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$high = $a->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $a->low) < 0) {
			$high = $high + 1;
			$ret = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x1 = new haxe__Int64____Int64($high, $low);
		$this2 = $x1;
		return $this2;
	}
	static function sub($a, $b) {
		$high = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a->low - $b->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low) < 0) {
			$high = $high - 1;
			$ret = $high + 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x = new haxe__Int64____Int64($high, $low);
		$this1 = $x;
		return $this1;
	}
	static function subInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$high = $a->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a->low - $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($a->low, $b1->low) < 0) {
			$high = $high - 1;
			$ret = $high + 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x1 = new haxe__Int64____Int64($high, $low);
		$this2 = $x1;
		return $this2;
	}
	static function intSub($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$a1 = $this1;
		$high = $a1->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a1->low - $b->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($a1->low, $b->low) < 0) {
			$high = $high - 1;
			$ret = $high + 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x1 = new haxe__Int64____Int64($high, $low);
		$this2 = $x1;
		return $this2;
	}
	static function mul($a, $b) {
		$mask = 65535;
		$al = $a->low & $mask;
		$ah = _hx_shift_right($a->low, 16);
		$bl = $b->low & $mask;
		$bh = _hx_shift_right($b->low, 16);
		$p00 = haxe__Int32_Int32_Impl_::mul($al, $bl);
		$p10 = haxe__Int32_Int32_Impl_::mul($ah, $bl);
		$p01 = haxe__Int32_Int32_Impl_::mul($al, $bh);
		$p11 = haxe__Int32_Int32_Impl_::mul($ah, $bh);
		$low = $p00;
		$high = ($p11 + (_hx_shift_right($p01, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p10, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$p01 = $p01 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $low + $p01 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $p01) < 0) {
			$high = $high + 1;
			$ret = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$p10 = $p10 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $low + $p10 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $p10) < 0) {
			$high = $high + 1;
			$ret1 = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$a1 = haxe__Int32_Int32_Impl_::mul($a->low, $b->high);
		$b1 = $a1 + haxe__Int32_Int32_Impl_::mul($a->high, $b->low);
		$high = $high + ($b1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$x = new haxe__Int64____Int64($high, $low);
		$this1 = $x;
		return $this1;
	}
	static function mulInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$mask = 65535;
		$al = $a->low & $mask;
		$ah = _hx_shift_right($a->low, 16);
		$bl = $b1->low & $mask;
		$bh = _hx_shift_right($b1->low, 16);
		$p00 = haxe__Int32_Int32_Impl_::mul($al, $bl);
		$p10 = haxe__Int32_Int32_Impl_::mul($ah, $bl);
		$p01 = haxe__Int32_Int32_Impl_::mul($al, $bh);
		$p11 = haxe__Int32_Int32_Impl_::mul($ah, $bh);
		$low = $p00;
		$high = ($p11 + (_hx_shift_right($p01, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p10, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$p01 = $p01 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $low + $p01 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $p01) < 0) {
			$high = $high + 1;
			$ret = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$p10 = $p10 << 16 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $low + $p10 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($low, $p10) < 0) {
			$high = $high + 1;
			$ret1 = $high - 1;
			$high = $high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$a1 = haxe__Int32_Int32_Impl_::mul($a->low, $b1->high);
		$b2 = $a1 + haxe__Int32_Int32_Impl_::mul($a->high, $b1->low);
		$high = $high + ($b2 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$x1 = new haxe__Int64____Int64($high, $low);
		$this2 = $x1;
		return $this2;
	}
	static function div($a, $b) {
		return haxe__Int64_Int64_Impl_::divMod($a, $b)->quotient;
	}
	static function divInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		return haxe__Int64_Int64_Impl_::divMod($a, $this1)->quotient;
	}
	static function intDiv($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$x1 = haxe__Int64_Int64_Impl_::divMod($this1, $b)->quotient;
		if($x1->high !== $x1->low >> 31) {
			throw new HException("Overflow");
		}
		$x2 = $x1->low;
		$x3 = new haxe__Int64____Int64($x2 >> 31, $x2);
		$this2 = $x3;
		return $this2;
	}
	static function mod($a, $b) {
		return haxe__Int64_Int64_Impl_::divMod($a, $b)->modulus;
	}
	static function modInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$x1 = haxe__Int64_Int64_Impl_::divMod($a, $this1)->modulus;
		if($x1->high !== $x1->low >> 31) {
			throw new HException("Overflow");
		}
		$x2 = $x1->low;
		$x3 = new haxe__Int64____Int64($x2 >> 31, $x2);
		$this2 = $x3;
		return $this2;
	}
	static function intMod($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$x1 = haxe__Int64_Int64_Impl_::divMod($this1, $b)->modulus;
		if($x1->high !== $x1->low >> 31) {
			throw new HException("Overflow");
		}
		$x2 = $x1->low;
		$x3 = new haxe__Int64____Int64($x2 >> 31, $x2);
		$this2 = $x3;
		return $this2;
	}
	static function eq($a, $b) {
		if($a->high === $b->high) {
			return $a->low === $b->low;
		} else {
			return false;
		}
	}
	static function eqInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		if($a->high === $b1->high) {
			return $a->low === $b1->low;
		} else {
			return false;
		}
	}
	static function neq($a, $b) {
		if(!($a->high !== $b->high)) {
			return $a->low !== $b->low;
		} else {
			return true;
		}
	}
	static function neqInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		if(!($a->high !== $b1->high)) {
			return $a->low !== $b1->low;
		} else {
			return true;
		}
	}
	static function lt($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp < 0;
	}
	static function ltInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$v = $a->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b1->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b1->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b1->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp < 0;
	}
	static function intLt($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$a1 = $this1;
		$v = $a1->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a1->low, $b->low);
		}
		$tmp = null;
		if($a1->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp < 0;
	}
	static function lte($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp <= 0;
	}
	static function lteInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$v = $a->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b1->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b1->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b1->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp <= 0;
	}
	static function intLte($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$a1 = $this1;
		$v = $a1->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a1->low, $b->low);
		}
		$tmp = null;
		if($a1->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp <= 0;
	}
	static function gt($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp > 0;
	}
	static function gtInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$v = $a->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b1->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b1->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b1->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp > 0;
	}
	static function intGt($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$a1 = $this1;
		$v = $a1->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a1->low, $b->low);
		}
		$tmp = null;
		if($a1->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp > 0;
	}
	static function gte($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp >= 0;
	}
	static function gteInt($a, $b) {
		$x = new haxe__Int64____Int64($b >> 31, $b);
		$this1 = $x;
		$b1 = $this1;
		$v = $a->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b1->low);
		}
		$tmp = null;
		if($a->high < 0) {
			if($b1->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b1->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp >= 0;
	}
	static function intGte($a, $b) {
		$x = new haxe__Int64____Int64($a >> 31, $a);
		$this1 = $x;
		$a1 = $this1;
		$v = $a1->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if($v !== 0) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a1->low, $b->low);
		}
		$tmp = null;
		if($a1->high < 0) {
			if($b->high < 0) {
				$tmp = $v;
			} else {
				$tmp = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp = $v;
			} else {
				$tmp = 1;
			}
		}
		return $tmp >= 0;
	}
	static function complement($a) {
		$x = new haxe__Int64____Int64(~$a->high, ~$a->low);
		$this1 = $x;
		return $this1;
	}
	static function hand($a, $b) {
		$x = new haxe__Int64____Int64($a->high & $b->high, $a->low & $b->low);
		$this1 = $x;
		return $this1;
	}
	static function hor($a, $b) {
		$x = new haxe__Int64____Int64($a->high | $b->high, $a->low | $b->low);
		$this1 = $x;
		return $this1;
	}
	static function hxor($a, $b) {
		$x = new haxe__Int64____Int64($a->high ^ $b->high, $a->low ^ $b->low);
		$this1 = $x;
		return $this1;
	}
	static function shl($a, $b) {
		$b = $b & 63;
		if($b === 0) {
			$x = new haxe__Int64____Int64($a->high, $a->low);
			$this1 = $x;
			return $this1;
		} else {
			if($b < 32) {
				$x1 = new haxe__Int64____Int64($a->high << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, 32 - $b), $a->low << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
				$this2 = $x1;
				return $this2;
			} else {
				$x2 = new haxe__Int64____Int64($a->low << $b - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
				$this3 = $x2;
				return $this3;
			}
		}
	}
	static function shr($a, $b) {
		$b = $b & 63;
		if($b === 0) {
			$x = new haxe__Int64____Int64($a->high, $a->low);
			$this1 = $x;
			return $this1;
		} else {
			if($b < 32) {
				$x1 = new haxe__Int64____Int64($a->high >> $b, $a->high << 32 - $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, $b));
				$this2 = $x1;
				return $this2;
			} else {
				$x2 = new haxe__Int64____Int64($a->high >> 31, $a->high >> $b - 32);
				$this3 = $x2;
				return $this3;
			}
		}
	}
	static function ushr($a, $b) {
		$b = $b & 63;
		if($b === 0) {
			$x = new haxe__Int64____Int64($a->high, $a->low);
			$this1 = $x;
			return $this1;
		} else {
			if($b < 32) {
				$x1 = new haxe__Int64____Int64(_hx_shift_right($a->high, $b), $a->high << 32 - $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, $b));
				$this2 = $x1;
				return $this2;
			} else {
				$x2 = new haxe__Int64____Int64(0, _hx_shift_right($a->high, $b - 32));
				$this3 = $x2;
				return $this3;
			}
		}
	}
	static function get_high($this1) {
		return $this1->high;
	}
	static function set_high($this1, $x) {
		return $this1->high = $x;
	}
	static function get_low($this1) {
		return $this1->low;
	}
	static function set_low($this1, $x) {
		return $this1->low = $x;
	}
	static $__properties__ = array("get_low" => "get_low","get_high" => "get_high");
	function __toString() { return 'haxe._Int64.Int64_Impl_'; }
}
