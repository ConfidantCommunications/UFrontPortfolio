<?php

// Generated by Haxe 3.4.4
class mtwin_mail_MetaPart {
	public function __construct($ctype = null, $sp = null, $charset = null) {
		if(!php_Boot::$skip_constructor) {
		$tmp = null;
		if($ctype === null) {
			$tmp = "text/plain";
		} else {
			$tmp = $ctype;
		}
		$this->contentType = $tmp;
		$this->subPart = $sp === true;
		$tmp1 = null;
		if($charset === null) {
			$tmp1 = "iso-8859-1";
		} else {
			$tmp1 = $charset;
		}
		$this->charset = $tmp1;
		$this->content = "";
		$this->parts = new HList();
		$this->headers = new haxe_ds_StringMap();
	}}
	public $content;
	public $parts;
	public $headers;
	public $contentType;
	public $charset;
	public $boundary;
	public $name;
	public $id;
	public $subPart;
	public function getContentType() {
		return $this->contentType;
	}
	public function getName($charsetOut = null) {
		$r = $this->name;
		$tmp = null;
		if($charsetOut !== null) {
			$tmp = $charsetOut !== $this->charset;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$cslc = strtolower($charsetOut);
			$charsetlc = strtolower($this->charset);
			$tmp1 = null;
			if($cslc !== "utf-8") {
				$tmp1 = $charsetlc === "utf-8";
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$r = haxe_Utf8::decode($r);
			} else {
				$tmp2 = null;
				if($charsetlc !== "utf-8") {
					$tmp2 = $cslc === "utf-8";
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$r = haxe_Utf8::encode($r);
				}
			}
		}
		return $r;
	}
	public function setName($n, $cs = null) {
		$this->name = $n;
		$tmp = null;
		if($cs !== null) {
			$tmp = $cs !== $this->charset;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$cslc = strtolower($cs);
			$charsetlc = strtolower($this->charset);
			$tmp1 = null;
			if($cslc !== "utf-8") {
				$tmp1 = $charsetlc === "utf-8";
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$this->name = haxe_Utf8::encode($this->name);
			} else {
				$tmp2 = null;
				if($charsetlc !== "utf-8") {
					$tmp2 = $cslc === "utf-8";
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$this->name = haxe_Utf8::decode($this->name);
				}
			}
		}
	}
	public function addPart($part) {
		$this->parts->add($part);
	}
	public function setContent($c) {
		$this->setHeader("Content-Transfer-Encoding", "quoted-printable");
		$this->content = $c;
	}
	public function setContentFromFile($filename, $type) {
		$a = _hx_explode("/", $filename);
		$this->name = $a->pop();
		$this->content = sys_io_File::getContent($filename);
		$this->contentType = $type;
		$this->setHeader("Content-Type", _hx_string_or_null($type) . "; name=\"" . _hx_string_or_null($this->name) . "\"");
		$this->setHeader("Content-Disposition", "attachment; filename=\"" . _hx_string_or_null($this->name) . "\"");
		$this->setHeader("Content-Transfer-Encoding", "base64");
	}
	public function setHeader($name, $content) {
		if($this->headers->exists($name)) {
			$l = $this->headers->get($name);
			if($l->length > 1) {
				throw new HException("Unable to setHeader, multiple header.");
			}
			$l[0] = $content;
		} else {
			$this->headers->set($name, (new _hx_array(array($content))));
		}
	}
	public function getHeader($name, $cs = null) {
		if(!$this->headers->exists($name)) {
			return null;
		}
		$r = _hx_array_get($this->headers->get($name), 0);
		$tmp = null;
		if($cs !== null) {
			$tmp = $cs !== $this->charset;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$cslc = strtolower($cs);
			$charsetlc = strtolower($this->charset);
			$tmp1 = null;
			if($cslc !== "utf-8") {
				$tmp1 = $charsetlc === "utf-8";
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$r = haxe_Utf8::decode($r);
			} else {
				$tmp2 = null;
				if($charsetlc !== "utf-8") {
					$tmp2 = $cslc === "utf-8";
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$r = haxe_Utf8::encode($r);
				}
			}
		}
		return $r;
	}
	public function addHeader($name, $content) {
		if($this->headers->exists($name)) {
			$tmp = $this->headers->get($name);
			$tmp->push($content);
		} else {
			$this->headers->set($name, (new _hx_array(array($content))));
		}
	}
	public function setDate($d = null) {
		if($d === null) {
			$d = Date::now();
		}
		$this->setHeader("Date", mtwin_DateFormat::formatRfc822($d));
	}
	public function getDate() {
		$d = $this->getHeader("Date", null);
		if($d === null) {
			return null;
		}
		return mtwin_DateFormat::parse($d);
	}
	public function setContentId($cid = null) {
		if($cid === null) {
			$t = $this->getHeader("Content-Id", null);
			if($t !== null) {
				return _hx_substr($t, 1, strlen($t) - 2);
			}
			$cid1 = _hx_string_or_null(mtwin_mail_Tools::randomEight()) . ".";
			$cid = _hx_string_or_null($cid1) . _hx_string_or_null(mtwin_mail_Tools::randomEight());
			$this->setHeader("Content-Id", "<" . _hx_string_or_null($cid) . ">");
		} else {
			$this->setHeader("Content-Id", "<" . _hx_string_or_null($cid) . ">");
		}
		return $cid;
	}
	public function htmlUseContentId($p) {
		$filename = $p->keys();
		while($filename->hasNext()) {
			$filename1 = $filename->next();
			$s = $this->content;
			$by = "cid:" . _hx_string_or_null($p->get($filename1));
			$tmp = null;
			if($filename1 === "") {
				$tmp = implode(str_split ($s), $by);
			} else {
				$tmp = str_replace($filename1, $by, $s);
			}
			$this->content = $tmp;
			unset($tmp,$s,$filename1,$by);
		}
	}
	public function htmlRemoveTab() {
		$this->content = mtwin_mail_MetaPart::$REG_START_TAB->replace($this->content, "");
	}
	public function get() {
		$boundary = "";
		if($this->parts->length > 0) {
			if(strtolower(_hx_substr($this->contentType, 0, 10)) !== "multipart/") {
				$this->contentType = "multipart/mixed";
			}
			$tmp = null;
			if($boundary !== null) {
				$tmp = strlen($boundary) === 0;
			} else {
				$tmp = true;
			}
			if($tmp) {
				$boundary1 = "----=" . _hx_string_or_null(mtwin_mail_Tools::randomEight()) . "_";
				$boundary2 = _hx_string_or_null($boundary1) . _hx_string_or_null(mtwin_mail_Tools::randomEight()) . ".";
				$boundary = _hx_string_or_null($boundary2) . _hx_string_or_null(mtwin_mail_Tools::randomEight());
			}
			$this->setHeader("Content-Type", _hx_string_or_null($this->contentType) . "; charset=\"" . _hx_string_or_null($this->charset) . "\"; boundary=\"" . _hx_string_or_null($boundary) . "\"");
		} else {
			if($this->name !== null) {
				$tmp1 = _hx_string_or_null($this->contentType) . "; name=\"";
				$this->setHeader("Content-Type", _hx_string_or_null($tmp1) . _hx_string_or_null(_hx_explode("\"", $this->name)->join("\\\"")) . "\"");
			} else {
				$this->setHeader("Content-Type", _hx_string_or_null($this->contentType) . "; charset=\"" . _hx_string_or_null($this->charset) . "\"");
			}
		}
		if(!$this->subPart) {
			$this->setHeader("MIME-Version", "1.0");
			$this->setHeader("X-Mailer", "haXe mailer");
		}
		$ret = new StringBuf();
		$myHeaders = new haxe_ds_StringMap();
		{
			$k = $this->headers->keys();
			while($k->hasNext()) {
				$k1 = $k->next();
				$myHeaders->set($k1, $this->headers->get($k1));
				unset($k1);
			}
		}
		{
			$_g = 0;
			$_g1 = mtwin_mail_MetaPart::$headerOrder;
			while($_g < $_g1->length) {
				$p = $_g1[$_g];
				$_g = $_g + 1;
				if($myHeaders->exists($p)) {
					{
						$_g2 = 0;
						$_g3 = $myHeaders->get($p);
						while($_g2 < $_g3->length) {
							$s = $_g3[$_g2];
							$_g2 = $_g2 + 1;
							$ret->add(mtwin_mail_Tools::formatHeader($p, $s, $this->charset));
							unset($s);
						}
						unset($_g3,$_g2);
					}
					$myHeaders->remove($p);
				}
				unset($p);
			}
		}
		{
			$k2 = $myHeaders->keys();
			while($k2->hasNext()) {
				$k3 = $k2->next();
				$_g4 = 0;
				$_g11 = $myHeaders->get($k3);
				while($_g4 < $_g11->length) {
					$s1 = $_g11[$_g4];
					$_g4 = $_g4 + 1;
					$ret->add(mtwin_mail_Tools::formatHeader($k3, $s1, $this->charset));
					unset($s1);
				}
				unset($k3,$_g4,$_g11);
			}
		}
		$ret->add("\x0D\x0A");
		if(strlen($this->content) > 0) {
			$_g5 = $this->getHeader("Content-Transfer-Encoding", null);
			switch($_g5) {
			case "base64":{
				$ret->add(_hx_string_or_null(mtwin_mail_Tools::encodeBase64($this->content)) . "\x0D\x0A");
			}break;
			case "quoted-printable":{
				$ret->add(_hx_string_or_null(mtwin_mail_Tools::encodeQuotedPrintable($this->content)) . "\x0D\x0A");
			}break;
			default:{
				$ret->add(_hx_string_or_null($this->content) . "\x0D\x0A");
			}break;
			}
		}
		if($this->parts->length > 0) {
			$pcp = new HList();
			{
				$p1 = $this->parts->iterator();
				while($p1->hasNext()) {
					$p2 = $p1->next();
					$pcp->add($p2);
					unset($p2);
				}
			}
			if($this->contentType === "multipart/alternative") {
				{
					$v = $pcp->iterator();
					while($v->hasNext()) {
						$v1 = $v->next();
						if($v1->contentType === "text/plain") {
							$ret->add("--" . _hx_string_or_null($boundary) . "\x0D\x0A" . _hx_string_or_null($v1->get()));
							$pcp->remove($v1);
						}
						unset($v1);
					}
				}
				{
					$v2 = $pcp->iterator();
					while($v2->hasNext()) {
						$v3 = $v2->next();
						if($v3->contentType === "text/html") {
							$ret->add("--" . _hx_string_or_null($boundary) . "\x0D\x0A" . _hx_string_or_null($v3->get()));
							$pcp->remove($v3);
						}
						unset($v3);
					}
				}
			}
			{
				$v4 = $pcp->iterator();
				while($v4->hasNext()) {
					$v5 = $v4->next();
					$ret->add("--" . _hx_string_or_null($boundary) . "\x0D\x0A" . _hx_string_or_null($v5->get()));
					unset($v5);
				}
			}
			$ret->add("--" . _hx_string_or_null($boundary) . "--\x0D\x0A");
		}
		return $ret->b;
	}
	public function parse($str, $id = null) {
		if($str === null) {
			throw new HException("unable to parse null");
		}
		if($id === null) {
			$this->subPart = false;
		}
		$this->id = $id;
		$head = new HList();
		$buf = new StringBuf();
		$i = 0;
		$oi = 0;
		while(true) {
			$i = _hx_index_of($str, "\x0A", $oi);
			if(!($i >= 0)) {
				break;
			}
			$ln = _hx_substr($str, $oi, $i - $oi);
			$tmp = null;
			if(strlen($ln) !== 0) {
				$tmp = $ln === "\x0D";
			} else {
				$tmp = true;
			}
			if($tmp) {
				$head->add($buf->b);
				break;
			} else {
				$tmp1 = _hx_deref(new EReg("^\\s", ""))->match($ln);
				if($tmp1) {
					$buf->add(mtwin_mail_Tools::removeCRLF($ln));
				} else {
					$head->add($buf->b);
					$buf = new StringBuf();
					$buf->add(mtwin_mail_Tools::removeCRLF($ln));
				}
				unset($tmp1);
			}
			$i = $i + 1;
			$oi = $i;
			unset($tmp,$ln);
		}
		$this->content = _hx_substr($str, $i, null);
		{
			$ln1 = $head->iterator();
			while($ln1->hasNext()) {
				$ln2 = $ln1->next();
				if(mtwin_mail_MetaPart::$REG_HEADER->match($ln2)) {
					$name = mtwin_mail_Tools::formatHeaderTitle(mtwin_mail_MetaPart::$REG_HEADER->matched(1));
					$s = mtwin_mail_MetaPart::$REG_HEADER->matched(2);
					$value = trim($s);
					if($this->headers->exists($name)) {
						$tmp2 = $this->headers->get($name);
						$tmp2->push($value);
						unset($tmp2);
					} else {
						$this->headers->set($name, (new _hx_array(array($value))));
					}
					unset($value,$s,$name);
				}
				unset($ln2);
			}
		}
		$ctype0 = "text";
		$ctype1 = "plain";
		$hctype = mtwin_mail_Tools::parseComplexHeader($this->getHeader("Content-Type", null));
		if($hctype !== null) {
			$t = _hx_explode("/", $hctype->value);
			$ctype0 = strtolower(trim($t[0]));
			if($t->length > 1) {
				$ctype1 = strtolower(trim($t[1]));
			} else {
				$ctype1 = "";
			}
			if($hctype->params->exists("charset")) {
				$this->charset = $hctype->params->get("charset");
			}
			if($hctype->params->exists("boundary")) {
				$this->boundary = $hctype->params->get("boundary");
			}
		}
		$this->contentType = _hx_string_or_null($ctype0) . "/" . _hx_string_or_null($ctype1);
		{
			$k = $this->headers->keys();
			while($k->hasNext()) {
				$k1 = $k->next();
				$a = $this->headers->get($k1);
				{
					$_g1 = 0;
					$_g = $a->length;
					while($_g1 < $_g) {
						$_g1 = $_g1 + 1;
						$i1 = $_g1 - 1;
						$a[$i1] = mtwin_mail_Tools::headerDecode($a[$i1], $this->charset);
						unset($i1);
					}
					unset($_g1,$_g);
				}
				unset($k1,$a);
			}
		}
		if($ctype0 === "multipart") {
			$tmp3 = null;
			if($this->boundary !== null) {
				$tmp3 = strlen($this->boundary) === 0;
			} else {
				$tmp3 = true;
			}
			if($tmp3) {
				$this->contentType = "text/plain";
				$ctype0 = "text";
				$ctype1 = "plain";
			} else {
				$this->splitContent();
			}
		}
		if($this->headers->exists("Content-Transfer-Encoding")) {
			$cte = strtolower($this->getHeader("Content-Transfer-Encoding", null));
			if($cte === "quoted-printable") {
				$this->content = mtwin_mail_Tools::decodeQuotedPrintable($this->content);
			} else {
				if($cte === "base64") {
					$this->content = mtwin_mail_Tools::decodeBase64($this->content);
				}
			}
		}
		$hctype = mtwin_mail_Tools::parseComplexHeader($this->getHeader("Content-Type", null));
		$tmp4 = null;
		if($hctype !== null) {
			$tmp4 = $hctype->params->exists("name");
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$this->name = $hctype->params->get("name");
		}
		$cdispo = mtwin_mail_Tools::parseComplexHeader($this->getHeader("Content-Disposition", null));
		$tmp5 = null;
		if($cdispo !== null) {
			$tmp5 = $cdispo->params->exists("filename");
		} else {
			$tmp5 = false;
		}
		if($tmp5) {
			$this->name = $cdispo->params->get("filename");
		}
	}
	public function splitContent() {
		$bound = mtwin_mail_Tools::pregQuote($this->boundary);
		$regStr = "(.*?)--" . _hx_string_or_null($bound) . "(.*)--" . _hx_string_or_null($bound) . "--";
		$reg = new EReg($regStr, "s");
		if($reg->match($this->content)) {
			$this->content = $reg->matched(1);
			$b = "--" . _hx_string_or_null($this->boundary);
			$ts = $reg->matched(2);
			$tmp = new _hx_array(array());
			$i = 0;
			$oi = 0;
			while(true) {
				$i = _hx_index_of($ts, $b, $oi);
				if(!($i >= 0)) {
					break;
				}
				$tmp->push(_hx_substr($ts, $oi, $i - $oi));
				$i = $i + strlen($b);
				$oi = $i;
			}
			$tmp->push(_hx_substr($ts, $oi, null));
			$myId = null;
			$myId1 = null;
			if($this->id !== null) {
				$myId1 = strlen($this->id) === 0;
			} else {
				$myId1 = true;
			}
			if($myId1) {
				$myId = "";
			} else {
				$myId = _hx_string_or_null($this->id) . ".";
			}
			$i1 = 0;
			{
				$_g = 0;
				while($_g < $tmp->length) {
					$str = $tmp[$_g];
					$_g = $_g + 1;
					$i1 = $i1 + 1;
					$p = $this->newPart("text/plain");
					$tmp1 = _hx_string_or_null(trim($str)) . "\x0D\x0A";
					$p->parse($tmp1, _hx_string_or_null($myId) . _hx_string_rec($i1, ""));
					unset($tmp1,$str,$p);
				}
			}
		}
	}
	public function newPart($ctype) {
		throw new HException("Part cannot be used directly : newPart need to be overrided");
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $headerOrder;
	static $REG_HEADER;
	static $REG_CRLF_END;
	static $REG_START_TAB;
	function __toString() { return 'mtwin.mail.MetaPart'; }
}
mtwin_mail_MetaPart::$headerOrder = (new _hx_array(array("Return-Path", "Received", "Date", "From", "Subject", "Sender", "To", "Cc", "Bcc", "Content-Type", "X-Mailer", "X-Originating-IP", "X-Originating-User")));
mtwin_mail_MetaPart::$REG_HEADER = new EReg("^([a-zA-Z0-9_\\-]+):(.*)\$", "");
mtwin_mail_MetaPart::$REG_CRLF_END = new EReg("(\x0D?\x0A)\$", "");
mtwin_mail_MetaPart::$REG_START_TAB = new EReg("^(\x09| )+", "");
