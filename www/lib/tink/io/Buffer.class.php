<?php

// Generated by Haxe 3.4.4
class tink_io_Buffer {
	public function __construct($bytes, $width) {
		if(!php_Boot::$skip_constructor) {
		$this->available = 0;
		$this->writable = true;
		$this->retainCount = 0;
		$this->zero = 0;
		$this->width = 0;
		$this->bytes = $bytes;
		$this->raw = $bytes->b;
		$this->width = $width;
	}}
	public $bytes;
	public $raw;
	public $width;
	public $zero;
	public $retainCount;
	public function retain() {
		$this->retainCount++;
		$self = $this;
		return array(new _hx_lambda(array(&$self), "tink_io_Buffer_0"), 'execute');
	}
	public $writable;
	public $available;
	public function get_size() {
		return $this->bytes->length;
	}
	public function get_end() {
		return _hx_mod(($this->zero + $this->available), $this->bytes->length);
	}
	public function get_freeBytes() {
		return $this->bytes->length - $this->available;
	}
	public function seal() {
		$this->writable = false;
	}
	public function content() {
		return $this->blitTo(haxe_io_Bytes::alloc($this->available));
	}
	public function blitTo($ret) {
		if($this->zero + $this->available <= $this->bytes->length) {
			$ret->blit(0, $this->bytes, $this->zero, $this->available);
		} else {
			$tmp = $this->bytes->length - $this->zero;
			$tmp1 = $this->bytes;
			$ret->blit($tmp, $tmp1, 0, $this->get_end());
			$ret->blit(0, $this->bytes, $this->zero, $this->bytes->length - $this->zero);
		}
		return $ret;
	}
	public function toString() {
		return "[Buffer " . _hx_string_rec($this->available, "") . "/" . _hx_string_rec($this->bytes->length, "") . "]";
	}
	public function safely($operation, $f) {
		try {
			return tink_core_Outcome::Success(call_user_func($f));
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(($e = $_ex_) instanceof haxe_io_Error){
				$tmp = null;
				if($e === haxe_io_Error::$Blocked) {
					$tmp = 0;
				} else {
					$tmp = -1;
				}
				return tink_core_Outcome::Success($tmp);
			}
			else if(($e1 = $_ex_) instanceof haxe_io_Eof){
				return tink_core_Outcome::Success(-1);
			}
			else if(($e2 = $_ex_) instanceof tink_core_TypedError){
				return tink_core_Outcome::Failure($e2);
			}
			else { $e3 = $_ex_;
			{
				$tmp1 = "" . _hx_string_or_null($operation) . " due to " . Std::string($e3);
				return tink_core_Outcome::Failure(tink_core_TypedError::withData(null, $tmp1, $e3, _hx_anonymous(array("fileName" => "Buffer.hx", "lineNumber" => 103, "className" => "tink.io.Buffer", "methodName" => "safely"))));
			}}
		}
	}
	public function tryWritingTo($name, $dest, $max = null) {
		if($max === null) {
			$max = 268435456;
		}
		$f = (property_exists($this, "writeTo") ? $this->writeTo: array($this, "writeTo"));
		$a1 = $dest;
		$a2 = $max;
		return $this->safely("Failed writing to " . _hx_string_or_null($name), array(new _hx_lambda(array(&$a1, &$a2, &$f), "tink_io_Buffer_1"), 'execute'));
	}
	public function tryReadingFrom($name, $source, $max = null) {
		if($max === null) {
			$max = 268435456;
		}
		$f = (property_exists($this, "readFrom") ? $this->readFrom: array($this, "readFrom"));
		$a1 = $source;
		$a2 = $max;
		return $this->safely("Failed reading from " . _hx_string_or_null($name), array(new _hx_lambda(array(&$a1, &$a2, &$f), "tink_io_Buffer_2"), 'execute'));
	}
	public function writeTo($dest, $max = null) {
		if($max === null) {
			$max = 268435456;
		}
		if($this->available === 0) {
			if($this->writable) {
				return 0;
			} else {
				$this->dispose();
				return -1;
			}
		}
		$toWrite = null;
		if($this->zero + $this->available > $this->bytes->length) {
			$toWrite = $this->bytes->length - $this->zero;
		} else {
			$toWrite = $this->available;
		}
		if($max < 0) {
			$max = 0;
		}
		if($max < $toWrite) {
			$toWrite = $max;
		}
		$transfered = $dest->writeBytes($this->bytes, $this->zero, $toWrite);
		if($transfered > 0) {
			$this->zero = _hx_mod(($this->zero + $transfered), $this->bytes->length);
			$tmp = $this;
			$tmp->available = $tmp->available - $transfered;
		}
		$tmp1 = null;
		if(!$this->writable) {
			$tmp1 = $this->available === 0;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			$this->dispose();
		}
		$this1 = $transfered;
		return $this1;
	}
	public function align() {
		$tmp = $this->zero;
		if($tmp < $this->get_end()) {
			return false;
		}
		$copy = null;
		if($this->width > 0) {
			$copy = tink_io_Buffer::allocBytes($this->width);
		} else {
			$copy = haxe_io_Bytes::alloc($this->bytes->length);
		}
		$this->blitTo($copy);
		$old = $this->bytes;
		$this->bytes = $copy;
		$this->raw = $copy->b;
		$this->zero = 0;
		tink_io_Buffer::poolBytes($old, $this->width);
		return true;
	}
	public function clear() {
		$this->zero = 0;
		$this->available = 0;
		$this->writable = true;
	}
	public function readFrom($source, $max = null) {
		if($max === null) {
			$max = 268435456;
		}
		if(!$this->writable) {
			return -1;
		}
		if($this->available === $this->bytes->length) {
			return 0;
		}
		$toRead = null;
		$toRead1 = $this->get_end();
		if($toRead1 < $this->zero) {
			$toRead = $this->bytes->length - $this->available;
		} else {
			$toRead2 = $this->bytes->length;
			$toRead = $toRead2 - $this->get_end();
		}
		if($max < 0) {
			$max = 0;
		}
		if($max < $toRead) {
			$toRead = $max;
		}
		$transfered = $this->bytes;
		$transfered1 = $source->readBytes($transfered, $this->get_end(), $toRead);
		if($transfered1 > 0) {
			$tmp = $this;
			$tmp->available = $tmp->available + $transfered1;
		}
		$this1 = $transfered1;
		return $this1;
	}
	public function dispose() {
		if($this->bytes->length > 0) {
			$old = $this->bytes;
			$this->bytes = tink_io_Buffer::$ZERO_BYTES;
			$this->raw = $this->bytes->b;
			$this->zero = 0;
			$this->available = 0;
			tink_io_Buffer::poolBytes($old, $this->width);
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $ZERO_BYTES;
	static function poolBytes($b, $width) {
		if($width >= 10) {
			$_this = tink_io_Buffer::$mutex;
			_hx_array_get(tink_io_Buffer::$pool, $width - 10)->push($b);
		}
	}
	static function sufficientWidthFor($minSize) {
		$tmp = $minSize > 268435456;
		$width = 15;
		$size = 1 << $width;
		while($size < $minSize) {
			$width = $width + 1;
			$size = 1 << $width;
		}
		return $width;
	}
	static function alloc($width = null) {
		if($width === null) {
			$width = 15;
		}
		if($width < 10) {
			$width = 10;
		}
		if($width > 28) {
			$width = 28;
		}
		return new tink_io_Buffer(tink_io_Buffer::allocBytes($width), $width);
	}
	static function allocBytes($width) {
		$_this = tink_io_Buffer::$mutex;
		$_g = _hx_array_get(tink_io_Buffer::$pool, $width - 10)->pop();
		if($_g === null) {
			return haxe_io_Bytes::alloc(1 << $width);
		} else {
			$v = $_g;
			return $v;
		}
	}
	static function releaseBytes($bytes) {
		{
			$_g = 10;
			while($_g < 28) {
				$_g = $_g + 1;
				$width = $_g - 1;
				if($bytes->length === 1 << $width) {
					tink_io_Buffer::poolBytes($bytes, $width);
					return true;
				}
				unset($width);
			}
		}
		return false;
	}
	static $MIN_WIDTH = 10;
	static $DEFAULT_WIDTH = 15;
	static $MAX_WIDTH = 28;
	static $mutex;
	static $pool;
	static function unmanaged($bytes) {
		return new tink_io_Buffer($bytes, -1);
	}
	static function wrap($bytes, $start, $len) {
		$ret = tink_io_Buffer::unmanaged($bytes);
		$ret->zero = $start;
		$ret->available = $len;
		return $ret;
	}
	static $__properties__ = array("get_freeBytes" => "get_freeBytes","get_end" => "get_end","get_size" => "get_size");
	function __toString() { return $this->toString(); }
}
tink_io_Buffer::$ZERO_BYTES = haxe_io_Bytes::alloc(0);
tink_io_Buffer::$mutex = new tink_io__Buffer_Mutex();
tink_io_Buffer::$pool = tink_io_Buffer_3();
function tink_io_Buffer_0(&$self) {
	{
		if($self === null) {
			return;
		}
		if(--$self->retainCount === 0) {
			$self->dispose();
		}
		$self = null;
	}
}
function tink_io_Buffer_1(&$a1, &$a2, &$f) {
	{
		return call_user_func_array($f, array($a1, $a2));
	}
}
function tink_io_Buffer_2(&$a1, &$a2, &$f) {
	{
		return call_user_func_array($f, array($a1, $a2));
	}
}
function tink_io_Buffer_3() {
	{
		$_g = (new _hx_array(array()));
		{
			$_g1 = 10;
			while($_g1 < 28) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$_g->push((new _hx_array(array())));
				unset($i);
			}
		}
		return $_g;
	}
}
