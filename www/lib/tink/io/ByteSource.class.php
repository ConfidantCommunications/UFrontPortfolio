<?php

// Generated by Haxe 3.4.4
class tink_io_ByteSource extends tink_io_IdealSourceBase {
	public function __construct($data, $offset = null) {
		if(!php_Boot::$skip_constructor) {
		if($offset === null) {
			$offset = 0;
		}
		$this->data = $data;
		$this->pos = $offset;
	}}
	public $data;
	public $pos;
	public function readBytes($into, $offset, $len) {
		if($this->pos >= $this->data->length) {
			return -1;
		} else {
			if($len <= 0) {
				return 0;
			} else {
				if($this->pos + $len > $this->data->length) {
					return $this->readBytes($into, $offset, $this->data->length - $this->pos);
				} else {
					$into->blit($offset, $this->data, $this->pos, $len);
					$tmp = $this;
					$tmp->pos = $tmp->pos + $len;
					return $len;
				}
			}
		}
	}
	public function allSafely() {
		$ret = null;
		if($this->pos === 0) {
			$ret = $this->data;
		} else {
			$ret = $this->data->sub($this->pos, $this->data->length - $this->pos);
		}
		$this->data = tink_io_Buffer::$ZERO_BYTES;
		$this->pos = 0;
		return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($ret));
	}
	public function append($other) {
		$_g = Std::instance($other, _hx_qtype("tink.io.ByteSource"));
		if($_g === null) {
			return parent::append($other);
		} else {
			$v = $_g;
			return $this->merge($v);
		}
	}
	public function prepend($other) {
		$_g = Std::instance($other, _hx_qtype("tink.io.ByteSource"));
		if($_g === null) {
			return parent::append($other);
		} else {
			$v = $_g;
			return $v->merge($this);
		}
	}
	public function merge($that) {
		$l1 = $this->data->length - $this->pos;
		$l2 = $that->data->length - $that->pos;
		$bytes = haxe_io_Bytes::alloc($l1 + $l2);
		$bytes->blit(0, $this->data, $this->pos, $l1);
		$bytes->blit($l1, $that->data, $that->pos, $l2);
		return new tink_io_ByteSource($bytes, 0);
	}
	public function pipeTo($dest, $options = null) {
		$_gthis = $this;
		$dest1 = $dest;
		$buf = tink_io_Buffer::wrap($this->data, $this->pos, $this->data->length - $this->pos);
		$initial = $buf->available;
		return tink_core__Future_Future_Impl_::async(array(new _hx_lambda(array(&$_gthis, &$buf, &$dest1, &$initial, &$options), "tink_io_ByteSource_0"), 'execute'), null);
	}
	public function toString() {
		return "[Byte Source " . _hx_string_rec($this->pos, "") . "/" . _hx_string_rec($this->data->length, "") . "]";
	}
	public function readSafely($into, $max = null) {
		if($max === null) {
			$max = 268435456;
		}
		return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($into->readFrom($this, $max)));
	}
	public function closeSafely() {
		$this->data = tink_io_Buffer::$ZERO_BYTES;
		$this->pos = 0;
		return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Noise::$Noise));
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function tink_io_ByteSource_0(&$_gthis, &$buf, &$dest1, &$initial, &$options, $cb) {
	{
		tink_io__Sink_Sink_Impl_::writeFull($dest1, $buf)->handle(array(new _hx_lambda(array(&$_gthis, &$buf, &$cb, &$dest1, &$initial, &$options), "tink_io_ByteSource_1"), 'execute'));
	}
}
function tink_io_ByteSource_1(&$_gthis, &$buf, &$cb, &$dest1, &$initial, &$options, $o) {
	{
		$_gthis1 = $_gthis;
		$_gthis1->pos = $_gthis1->pos + ($buf->available - $initial);
		$tmp = null;
		switch($o->index) {
		case 0:{
			switch(_hx_deref($o)->params[0]) {
			case false:{
				$tmp = tink_io_PipeResult::$SinkEnded;
			}break;
			case true:{
				$tmp1 = null;
				if($options !== null) {
					$tmp1 = $options->end;
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					$dest1->close();
				}
				$tmp = tink_io_PipeResult::$AllWritten;
			}break;
			}
		}break;
		case 1:{
			$e = _hx_deref($o)->params[0];
			$tmp = tink_io_PipeResult::SinkFailed($e);
		}break;
		}
		call_user_func_array($cb, array($tmp));
		if($_gthis->pos === $_gthis->data->length) {
			$_gthis->closeSafely();
		}
	}
}
