<?php

// Generated by Haxe 3.4.4
class tink_io_Splitter implements tink_io_StreamParser{
	public function __construct($delim) {
		if(!php_Boot::$skip_constructor) {
		$this->delim = $delim;
	}}
	public $atEnd;
	public $out;
	public $delim;
	public $result;
	public function minSize() {
		return $this->delim->length;
	}
	public function reset() {
		$this->out = new haxe_io_BytesBuffer();
	}
	public function writeBytes($bytes, $start, $length) {
		if(!$this->atEnd) {
			if($length < $this->delim->length) {
				$length = 0;
			}
		}
		if($length > 0) {
			{
				$_g1 = 0;
				$_g = $length;
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$i = $_g1 - 1;
					$found = true;
					{
						$_g3 = 0;
						$_g2 = $this->delim->length;
						while($_g3 < $_g2) {
							$_g3 = $_g3 + 1;
							$dpos = $_g3 - 1;
							$this1 = $bytes->b;
							$tmp = ord($this1->s[$start + $i + $dpos]);
							$this2 = $this->delim->b;
							if($tmp !== ord($this2->s[$dpos])) {
								$found = false;
								break;
							}
							unset($tmp,$this2,$this1,$dpos);
						}
						unset($_g3,$_g2);
					}
					if($found) {
						{
							$tmp1 = null;
							$tmp2 = null;
							if($start >= 0) {
								$tmp2 = $i < 0;
							} else {
								$tmp2 = true;
							}
							if(!$tmp2) {
								$tmp1 = $start + $i > $bytes->length;
							} else {
								$tmp1 = true;
							}
							if($tmp1) {
								throw new HException(haxe_io_Error::$OutsideBounds);
							}
							$_this = $this->out;
							$_this1 = $_this->b;
							$this3 = $bytes->b;
							$x = new php__BytesData_Wrapper(substr($this3->s, $start, $i));
							$this4 = $x;
							$_this->b = _hx_string_or_null($_this1) . _hx_string_or_null($this4->s);
							unset($x,$tmp2,$tmp1,$this4,$this3,$_this1,$_this);
						}
						$this->result = haxe_ds_Option::Some($this->out->getBytes());
						$this->reset();
						return $i + $this->delim->length;
					}
					unset($i,$found);
				}
			}
			{
				$tmp3 = null;
				$tmp4 = null;
				if($start >= 0) {
					$tmp4 = $length < 0;
				} else {
					$tmp4 = true;
				}
				if(!$tmp4) {
					$tmp3 = $start + $length > $bytes->length;
				} else {
					$tmp3 = true;
				}
				if($tmp3) {
					throw new HException(haxe_io_Error::$OutsideBounds);
				}
				$_this2 = $this->out;
				$_this3 = $_this2->b;
				$this5 = $bytes->b;
				$x1 = new php__BytesData_Wrapper(substr($this5->s, $start, $length));
				$this6 = $x1;
				$_this2->b = _hx_string_or_null($_this3) . _hx_string_or_null($this6->s);
			}
		}
		return $length;
	}
	public function progress($buffer) {
		if((is_object($_t = $this->result) && ($_t instanceof Enum) ? $_t != haxe_ds_Option::$None : !_hx_equal($_t, haxe_ds_Option::$None))) {
			$this->reset();
			$this->result = haxe_ds_Option::$None;
		}
		if($buffer->bytes->length - $buffer->zero <= $this->delim->length) {
			$buffer->align();
		}
		$this->atEnd = !$buffer->writable;
		$buffer->writeTo($this, null);
		return tink_core_Outcome::Success($this->result);
	}
	public function eof() {
		return tink_core_Outcome::Success($this->out->getBytes());
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'tink.io.Splitter'; }
}
