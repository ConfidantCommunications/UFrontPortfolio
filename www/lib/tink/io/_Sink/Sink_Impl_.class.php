<?php

// Generated by Haxe 3.4.4
class tink_io__Sink_Sink_Impl_ {
	public function __construct(){}
	static function writeFull($this1, $buffer) {
		$self = $this1;
		return tink_core__Future_Future_Impl_::async(array(new _hx_lambda(array(&$buffer, &$self), "tink_io__Sink_Sink_Impl__0"), 'execute'), null);
	}
	static function inMemory() {
		return tink_io__Sink_Sink_Impl_::ofOutput("Memory sink", new haxe_io_BytesOutput(), tink_io__Worker_Worker_Impl_::$EAGER);
	}
	static function async($writer, $closer) {
		return new tink_io_AsyncSink($writer, $closer);
	}
	static function flatten($s) {
		return new tink_io_FutureSink($s);
	}
	static function ofOutput($name, $target, $worker = null) {
		return new tink_io_StdSink($name, $target, $worker);
	}
	static $stdout;
	function __toString() { return 'tink.io._Sink.Sink_Impl_'; }
}
tink_io__Sink_Sink_Impl_::$stdout = tink_io__Sink_Sink_Impl_::ofOutput("stdout", Sys::stdout(), null);
function tink_io__Sink_Sink_Impl__0(&$buffer, &$self, $cb) {
	{
		$flush = null;
		$flush = array(new _hx_lambda(array(&$buffer, &$cb, &$flush, &$self), "tink_io__Sink_Sink_Impl__1"), 'execute');
		$flush1 = $flush;
		call_user_func($flush1);
	}
}
function tink_io__Sink_Sink_Impl__1(&$buffer, &$cb, &$flush, &$self) {
	{
		if($buffer->available === 0) {
			call_user_func_array($cb, array(tink_core_Outcome::Success(true)));
		} else {
			$self->write($buffer)->handle(array(new _hx_lambda(array(&$cb, &$flush), "tink_io__Sink_Sink_Impl__2"), 'execute'));
		}
	}
}
function tink_io__Sink_Sink_Impl__2(&$cb, &$flush, $o) {
	{
		switch($o->index) {
		case 0:{
			$p = _hx_deref($o)->params[0];
			if($p < 0) {
				call_user_func_array($cb, array(tink_core_Outcome::Success(false)));
			} else {
				call_user_func($flush);
			}
		}break;
		case 1:{
			$e = _hx_deref($o)->params[0];
			call_user_func_array($cb, array(tink_core_Outcome::Failure($e)));
		}break;
		}
	}
}
