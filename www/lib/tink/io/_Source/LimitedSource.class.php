<?php

// Generated by Haxe 3.4.4
class tink_io__Source_LimitedSource extends tink_io_SourceBase {
	public function __construct($target, $limit) {
		if(!php_Boot::$skip_constructor) {
		$this->surplus = 0;
		$this->bytesRead = 0;
		$this->target = $target;
		$this->limit = $limit;
	}}
	public $limit;
	public $bytesRead;
	public $target;
	public $surplus;
	public function read($into, $maxb = null) {
		if($maxb === null) {
			$maxb = 1073741824;
		}
		$_gthis = $this;
		if($this->bytesRead >= $this->limit) {
			return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success(-1)));
		} else {
			return tink_core__Future_Future_Impl_::async(array(new _hx_lambda(array(&$_gthis, &$into, &$maxb), "tink_io__Source_LimitedSource_0"), 'execute'), null);
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'tink.io._Source.LimitedSource'; }
}
function tink_io__Source_LimitedSource_0(&$_gthis, &$into, &$maxb, $cb) {
	{
		if($maxb > $_gthis->limit - $_gthis->bytesRead) {
			$maxb = $_gthis->limit - $_gthis->bytesRead;
		}
		$tmp = $_gthis->target->read($into, $maxb);
		$tmp->handle(array(new _hx_lambda(array(&$_gthis, &$cb), "tink_io__Source_LimitedSource_1"), 'execute'));
	}
}
function tink_io__Source_LimitedSource_1(&$_gthis, &$cb, $x) {
	{
		if($x->index === 0) {
			$p = _hx_deref($x)->params[0];
			$_gthis1 = $_gthis;
			$tmp1 = null;
			if($p < 0) {
				$tmp1 = 0;
			} else {
				$tmp1 = $p;
			}
			$_gthis1->bytesRead = $_gthis1->bytesRead + $tmp1;
		}
		call_user_func_array($cb, array($x));
	}
}
