<?php

// Generated by Haxe 3.4.4
class tink_io__Source_Source_Impl_ {
	public function __construct(){}
	static function read($this1, $into, $max = null) {
		if($max === null) {
			$max = 1073741824;
		}
		return $this1->read($into, $max);
	}
	static function close($this1) {
		return $this1->close();
	}
	static function all($this1) {
		return $this1->all();
	}
	static function prepend($this1, $other) {
		return $this1->prepend($other);
	}
	static function append($this1, $other) {
		return $this1->append($other);
	}
	static function pipeTo($this1, $dest, $options = null) {
		return $this1->pipeTo($dest, $options);
	}
	static function idealize($this1, $onError) {
		return $this1->idealize($onError);
	}
	static function parse($this1, $parser) {
		return $this1->parse($parser);
	}
	static function parseWhile($this1, $parser, $consumer) {
		return $this1->parseWhile($parser, $consumer);
	}
	static function parseStream($this1, $parser, $rest = null) {
		return $this1->parseStream($parser, $rest);
	}
	static function split($this1, $delim) {
		return $this1->split($delim);
	}
	static function skip($this1, $length) {
		$this2 = tink_io__Source_Source_Impl_::limit($this1, $length);
		$this3 = tink_io_BlackHole::$INST;
		$this4 = $this2->pipeTo($this3, null);
		$ret = $this4->map(array(new _hx_lambda(array(&$this1), "tink_io__Source_Source_Impl__0"), 'execute'));
		return tink_io__Source_Source_Impl_::flatten($ret->gather());
	}
	static function limit($this1, $length) {
		return new tink_io__Source_LimitedSource($this1, $length);
	}
	static function async($f, $close) {
		return new tink_io__Source_AsyncSource($f, $close);
	}
	static function failure($e) {
		return new tink_io__Source_FailedSource($e);
	}
	static function ofInput($name, $input, $worker = null) {
		return new tink_io__Source_StdSource($name, $input, $worker);
	}
	static $stdin;
	static function flatten($s) {
		return new tink_io__Source_FutureSource($s);
	}
	static function fromBytes($b) {
		$tmp = null;
		if($b === null) {
			$tmp = tink_io_Empty::$instance;
		} else {
			$tmp = new tink_io_ByteSource($b, 0);
		}
		return $tmp;
	}
	static function fromString($s) {
		return tink_io__Source_Source_Impl_::fromBytes(haxe_io_Bytes::ofString($s));
	}
	function __toString() { return 'tink.io._Source.Source_Impl_'; }
}
tink_io__Source_Source_Impl_::$stdin = tink_io__Source_Source_Impl_::ofInput("stdin", Sys::stdin(), null);
function tink_io__Source_Source_Impl__0(&$this1, $o) {
	{
		switch($o->index) {
		case 0:{
			return tink_core_Outcome::Success($this1);
		}break;
		case 3:{
			$e = _hx_deref($o)->params[0];
			return tink_core_Outcome::Failure($e);
		}break;
		}
	}
}
