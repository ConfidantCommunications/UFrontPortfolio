<?php

// Generated by Haxe 3.4.4
class tink_streams_ConcatStream extends tink_streams_StreamBase {
	public function __construct($parts) {
		if(!php_Boot::$skip_constructor) {
		$this->parts = $parts;
	}}
	public $parts;
	public function filter($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_0"), 'execute'));
	}
	public function filterAsync($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_1"), 'execute'));
	}
	public function map($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_2"), 'execute'));
	}
	public function mapAsync($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_3"), 'execute'));
	}
	public function merge($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_4"), 'execute'));
	}
	public function mergeAsync($item) {
		return $this->transform(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_5"), 'execute'));
	}
	public function transform($t) {
		$_g = (new _hx_array(array()));
		{
			$_g1 = 0;
			$_g2 = $this->parts;
			while($_g1 < $_g2->length) {
				$p = $_g2[$_g1];
				$_g1 = $_g1 + 1;
				$_g->push(call_user_func_array($t, array($p)));
				unset($p);
			}
		}
		return new tink_streams_ConcatStream($_g);
	}
	public function withAll($f) {
		$_gthis = $this;
		$_g = $this->parts;
		if($_g->length === 0) {
			return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success(true)));
		} else {
			return tink_core__Future_Future_Impl_::async(array(new _hx_lambda(array(&$_gthis, &$f), "tink_streams_ConcatStream_6"), 'execute'), null);
		}
	}
	public function hforEach($item) {
		return $this->withAll(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_7"), 'execute'));
	}
	public function forEachAsync($item) {
		return $this->withAll(array(new _hx_lambda(array(&$item), "tink_streams_ConcatStream_8"), 'execute'));
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function make($parts) {
		$flat = (new _hx_array(array()));
		{
			$_g = 0;
			while($_g < $parts->length) {
				$p = $parts[$_g];
				$_g = $_g + 1;
				if(Std::is($p, _hx_qtype("tink.streams.ConcatStream"))) {
					$_g1 = 0;
					$_g2 = $p->parts;
					while($_g1 < $_g2->length) {
						$p1 = $_g2[$_g1];
						$_g1 = $_g1 + 1;
						$flat->push($p1);
						unset($p1);
					}
					unset($_g2,$_g1);
				} else {
					$flat->push($p);
				}
				unset($p);
			}
		}
		return new tink_streams_ConcatStream($flat);
	}
	function __toString() { return 'tink.streams.ConcatStream'; }
}
function tink_streams_ConcatStream_0(&$item, $x) {
	{
		return $x->filter($item);
	}
}
function tink_streams_ConcatStream_1(&$item, $x) {
	{
		return $x->filterAsync($item);
	}
}
function tink_streams_ConcatStream_2(&$item, $x) {
	{
		return $x->map($item);
	}
}
function tink_streams_ConcatStream_3(&$item, $x) {
	{
		return $x->mapAsync($item);
	}
}
function tink_streams_ConcatStream_4(&$item, $x) {
	{
		return $x->merge($item);
	}
}
function tink_streams_ConcatStream_5(&$item, $x) {
	{
		return $x->mergeAsync($item);
	}
}
function tink_streams_ConcatStream_6(&$_gthis, &$f, $cb) {
	{
		call_user_func_array($f, array($_gthis->parts[0]))->handle(array(new _hx_lambda(array(&$_gthis, &$cb, &$f), "tink_streams_ConcatStream_9"), 'execute'));
	}
}
function tink_streams_ConcatStream_7(&$item, $s) {
	{
		return $s->hforEach($item);
	}
}
function tink_streams_ConcatStream_8(&$item, $s) {
	{
		return $s->forEachAsync($item);
	}
}
function tink_streams_ConcatStream_9(&$_gthis, &$cb, &$f, $x) {
	{
		switch($x->index) {
		case 0:{
			$v = _hx_deref($x)->params[0];
			if($v) {
				$_gthis->parts->shift();
				$_gthis->withAll($f)->handle($cb);
			} else {
				call_user_func_array($cb, array($x));
			}
		}break;
		case 1:{
			$e = _hx_deref($x)->params[0];
			call_user_func_array($cb, array($x));
		}break;
		}
	}
}
