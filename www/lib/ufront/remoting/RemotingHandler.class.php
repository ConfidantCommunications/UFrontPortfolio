<?php

// Generated by Haxe 3.4.4
class ufront_remoting_RemotingHandler implements ufront_app_UFRequestHandler{
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$this->apiContexts = new HList();
		$this->apis = new HList();
	}}
	public $apiContexts;
	public $apis;
	public $context;
	public function loadApi($api) {
		$this->apis->push($api);
	}
	public function loadApis($newAPIs) {
		$api = $newAPIs->iterator();
		while($api->hasNext()) {
			$api1 = $api->next();
			$this->apis->push($api1);
			unset($api1);
		}
	}
	public function loadApiContext($apiContext) {
		$this->apiContexts->push($apiContext);
		{
			$newAPIs = ufront_api_UFApiContext::getApisInContext($apiContext);
			{
				$api = $newAPIs->iterator();
				while($api->hasNext()) {
					$api1 = $api->next();
					$this->apis->push($api1);
					unset($api1);
				}
			}
		}
	}
	public function handleRequest($httpContext) {
		$doneTrigger = new tink_core_FutureTrigger();
		$this1 = $httpContext->request->get_clientHeaders();
		if($this1->exists(strtolower("X-Haxe-Remoting"))) {
			$r = $httpContext->response;
			$remotingResponse = null;
			$r->setOk();
			$path = null;
			$args = null;
			try {
				$this->initializeContext($httpContext->injector);
				$params = $httpContext->request->get_params();
				if(!$params->exists("__x")) {
					throw new HException("Remoting call did not have parameter `__x` which describes which API call to make.  Aborting");
				}
				$remotingCall = ufront_core__MultiValueMap_MultiValueMap_Impl_::get($params, "__x");
				$u = new ufront_remoting_RemotingUnserializer($remotingCall, $httpContext->request->get_files());
				try {
					$path = $u->unserialize();
					$args = $u->unserialize();
					{
						$_g1 = 0;
						$_g = $args->length;
						while($_g1 < $_g) {
							$_g1 = $_g1 + 1;
							$i = $_g1 - 1;
							$baseUpload = Std::instance($args[$i], _hx_qtype("ufront.web.upload.BaseUpload"));
							$tmp = null;
							if($baseUpload !== null) {
								$tmp = $baseUpload->attachedUpload !== null;
							} else {
								$tmp = false;
							}
							if($tmp) {
								$args[$i] = $baseUpload->attachedUpload;
							}
							unset($tmp,$i,$baseUpload);
						}
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e = $_ex_;
					{
						throw new HException("Unable to deserialize remoting call: " . Std::string($e) . ". Remoting call string: " . _hx_string_or_null($remotingCall));
					}
				}
				$apiCallFinished = $this->executeApiCall($path, $args, $this->context, $httpContext->actionContext);
				$ret = $apiCallFinished->map(array(new _hx_lambda(array(), "ufront_remoting_RemotingHandler_0"), 'execute'));
				$remotingResponse = $ret->gather();
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e1 = $_ex_;
				{
					$error = $e1;
					$apiNotFoundMessages = (new _hx_array(array("Invalid path", "No such object", "Can't access", "No such method")));
					$tmp1 = null;
					$tmp2 = null;
					$tmp3 = null;
					if($path !== null) {
						$tmp3 = $args !== null;
					} else {
						$tmp3 = false;
					}
					if($tmp3) {
						$tmp2 = Std::is($e1, _hx_qtype("String"));
					} else {
						$tmp2 = false;
					}
					if($tmp2) {
						$tmp1 = Lambda::exists($apiNotFoundMessages, array(new _hx_lambda(array(&$error), "ufront_remoting_RemotingHandler_1"), 'execute'));
					} else {
						$tmp1 = false;
					}
					if($tmp1) {
						$v = "Unable to access " . _hx_string_or_null($path->join(".")) . " - API Not Found (";
						$v1 = _hx_string_or_null($v) . _hx_string_or_null($error) . "). See ";
						$remotingResponse = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(_hx_string_or_null($v1) . Std::string($this->context->objects)));
						$r->setNotFound();
					} else {
						$r->setInternalError();
						$remotingResponse = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($this->remotingError($e1, $httpContext)));
					}
				}
			}
			$remotingResponse->handle(array(new _hx_lambda(array(&$doneTrigger, &$httpContext, &$r), "ufront_remoting_RemotingHandler_2"), 'execute'));
		} else {
			$doneTrigger->trigger(tink_core_Outcome::Success(tink_core_Noise::$Noise));
		}
		return $doneTrigger;
	}
	public function initializeContext($injector) {
		$this->context = new haxe_remoting_Context();
		{
			$apiContextClass = $this->apiContexts->iterator();
			while($apiContextClass->hasNext()) {
				$apiContextClass1 = $apiContextClass->next();
				$apiContext = $injector->_instantiate($apiContextClass1);
				{
					$_g = 0;
					$_g1 = Reflect::fields($apiContext);
					while($_g < $_g1->length) {
						$fieldName = $_g1[$_g];
						$_g = $_g + 1;
						$api = Reflect::field($apiContext, $fieldName);
						if(Reflect::isObject($api)) {
							$this->context->addObject($fieldName, $api, false);
						}
						unset($fieldName,$api);
					}
					unset($_g1,$_g);
				}
				unset($apiContextClass1,$apiContext);
			}
		}
		{
			$apiClass = $this->apis->iterator();
			while($apiClass->hasNext()) {
				$apiClass1 = $apiClass->next();
				$className = Type::getClassName($apiClass1);
				$api1 = $injector->_instantiate($apiClass1);
				$this->context->addObject($className, $api1, false);
				unset($className,$apiClass1,$api1);
			}
		}
	}
	public function executeApiCall($path, $args, $remotingContext, $actionContext) {
		if($remotingContext->objects->exists($path[0]) === false) {
			throw new HException("Invalid path " . _hx_string_or_null($path->join(".")));
		}
		$actionContext->handler = $this;
		$actionContext->action = $path[$path->length - 1];
		$actionContext->controller = $remotingContext->objects->get($path[0])->obj;
		$actionContext->args = $args;
		$returnType = null;
		try {
			$fieldsMeta = haxe_rtti_Meta::getFields(Type::getClass($actionContext->controller));
			$actionMeta = Reflect::field($fieldsMeta, $actionContext->action);
			$returnType = $actionMeta->returnType[0];
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$returnType = 0;
			}
		}
		$this1 = $returnType;
		$flags = $this1;
		$result = $remotingContext->call($path, $args);
		if(($flags & 1 << ufront_api_ApiReturnType::$ARTFuture->index) !== 0) {
			return $result;
		} else {
			if(($flags & 1 << ufront_api_ApiReturnType::$ARTVoid->index) !== 0) {
				return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(null));
			} else {
				return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($result));
			}
		}
	}
	public function remotingError($e, $httpContext) {
		$httpContext->messages->push(_hx_anonymous(array("msg" => $e, "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 209, "className" => "ufront.remoting.RemotingHandler", "methodName" => "remotingError")), "type" => ufront_log_MessageType::$MError)));
		$this1 = $httpContext->request->get_clientHeaders();
		if($this1->exists(strtolower("X-Ufront-Remoting"))) {
			$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s->serializeException($e);
			$serializedException = "hxe" . _hx_string_or_null($s->toString());
			return $serializedException;
		} else {
			$s1 = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s1->serializeException($e);
			return "hxr" . _hx_string_or_null($s1->toString());
		}
	}
	public function toString() {
		return "ufront.remoting.RemotingHandler";
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function ufront_remoting_RemotingHandler_0($data) {
	{
		$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
		$s->serialize($data);
		return "hxr" . _hx_string_or_null($s->toString());
	}
}
function ufront_remoting_RemotingHandler_1(&$error, $msg) {
	{
		return StringTools::startsWith($error, $msg);
	}
}
function ufront_remoting_RemotingHandler_2(&$doneTrigger, &$httpContext, &$r, $response) {
	{
		$r->set_contentType("application/x-haxe-remoting");
		$r->clearContent();
		$r->write($response);
		$httpContext1 = $httpContext;
		$httpContext1->completion = $httpContext1->completion | 1 << ufront_web_context_RequestCompletion::$CRequestHandlersComplete->index;
		$doneTrigger->trigger(tink_core_Outcome::Success(tink_core_Noise::$Noise));
	}
}
