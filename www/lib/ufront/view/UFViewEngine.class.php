<?php

// Generated by Haxe 3.4.4
class ufront_view_UFViewEngine {
	public function __construct($cachingEnabled = null) {
		if(!php_Boot::$skip_constructor) {
		if($cachingEnabled === null) {
			$cachingEnabled = ufront_view_UFViewEngine::$cacheEnabledByDefault;
		}
		if($cachingEnabled) {
			$this->cache = new haxe_ds_StringMap();
		}
		$this->engines = (new _hx_array(array()));
	}}
	public $engines;
	public $cache;
	public function getTemplate($path, $templatingEngine = null) {
		$_gthis = $this;
		$tmp = null;
		if($this->cache !== null) {
			$tmp = $this->cache->exists($path);
		} else {
			$tmp = false;
		}
		if($tmp) {
			$cached = $this->cache->get($path);
			$tmp1 = null;
			if($templatingEngine !== null) {
				$tmp1 = $templatingEngine->type === $cached->a;
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success((property_exists($cached, "b") ? $cached->b: array($cached, "b")))));
			}
		}
		$tplStrReady = new tink_core_FutureTrigger();
		$ext = haxe_io_Path::extension($path);
		$finalPath = null;
		$tmp2 = null;
		if($templatingEngine !== null) {
			$tmp2 = $ext !== "";
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$finalPath = $path;
			$this->getTemplateString($finalPath)->handle(array(new _hx_lambda(array(&$path, &$tplStrReady), "ufront_view_UFViewEngine_0"), 'execute'));
		} else {
			$tmp4 = null;
			if($templatingEngine !== null) {
				$tmp4 = $ext === "";
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$exts = $templatingEngine->extensions->copy();
				$testNextExtension = null;
				$testNextExtension = array(new _hx_lambda(array(&$_gthis, &$exts, &$finalPath, &$path, &$templatingEngine, &$testNextExtension, &$tplStrReady), "ufront_view_UFViewEngine_1"), 'execute');
				$testNextExtension4 = $testNextExtension;
				call_user_func($testNextExtension4);
			} else {
				$tmp5 = null;
				if($templatingEngine === null) {
					$tmp5 = $ext !== "";
				} else {
					$tmp5 = false;
				}
				if($tmp5) {
					$tplEngines = $this->engines->copy();
					$testNextEngine = null;
					$testNextEngine = array(new _hx_lambda(array(&$_gthis, &$ext, &$finalPath, &$path, &$templatingEngine, &$testNextEngine, &$tplEngines, &$tplStrReady), "ufront_view_UFViewEngine_2"), 'execute');
					$testNextEngine3 = $testNextEngine;
					call_user_func($testNextEngine3);
				} else {
					$tmp6 = null;
					if($templatingEngine === null) {
						$tmp6 = $ext === "";
					} else {
						$tmp6 = false;
					}
					if($tmp6) {
						$tplEngines1 = $this->engines->copy();
						$engine1 = null;
						$extensions = (new _hx_array(array()));
						$extensionsUsed = (new _hx_array(array()));
						$ext2 = null;
						$testNextEngineOrExtension = null;
						$testNextEngineOrExtension = array(new _hx_lambda(array(&$_gthis, &$engine1, &$ext2, &$extensions, &$extensionsUsed, &$finalPath, &$path, &$templatingEngine, &$testNextEngineOrExtension, &$tplEngines1, &$tplStrReady), "ufront_view_UFViewEngine_3"), 'execute');
						$testNextEngineOrExtension5 = $testNextEngineOrExtension;
						call_user_func($testNextEngineOrExtension5);
					}
				}
			}
		}
		return tink_core__Future_Future_Impl_::_tryFailingMap($tplStrReady, array(new _hx_lambda(array(&$_gthis, &$finalPath, &$path, &$templatingEngine), "ufront_view_UFViewEngine_4"), 'execute'));
	}
	public function getTemplateString($path) {
		$v = tink_core_Outcome::Failure(new tink_core_TypedError(null, "Attempting to fetch template " . _hx_string_or_null($path) . " with UFViewEngine.  This is an abstract class, you must use one of the ViewEngine implementations.", _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 226, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplateString"))));
		return new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($v));
	}
	public function addTemplatingEngine($engine) {
		$this->engines->push($engine);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $cacheEnabledByDefault = true;
	function __toString() { return 'ufront.view.UFViewEngine'; }
}
function ufront_view_UFViewEngine_0(&$path, &$tplStrReady, $result) {
	{
		switch($result->index) {
		case 0:{
			switch(_hx_deref($result)->params[0]->index) {
			case 0:{
				$tpl = _hx_deref(_hx_deref($result)->params[0])->params[0];
				$tplStrReady->trigger(tink_core_Outcome::Success($tpl));
			}break;
			case 1:{
				$tmp3 = tink_core_Outcome::Failure(new tink_core_TypedError(null, "Template " . _hx_string_or_null($path) . " not found", _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 115, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
				$tplStrReady->trigger($tmp3);
			}break;
			}
		}break;
		case 1:{
			$err = _hx_deref($result)->params[0];
			$tplStrReady->trigger(tink_core_Outcome::Failure($err));
		}break;
		}
	}
}
function ufront_view_UFViewEngine_1(&$_gthis, &$exts, &$finalPath, &$path, &$templatingEngine, &$testNextExtension, &$tplStrReady) {
	{
		if($exts->length > 0) {
			$ext1 = $exts->shift();
			$finalPath = haxe_io_Path::withExtension($path, $ext1);
			$_gthis->getTemplateString($finalPath)->handle(array(new _hx_lambda(array(&$testNextExtension, &$tplStrReady), "ufront_view_UFViewEngine_5"), 'execute'));
		} else {
			$testNextExtension1 = "No template found for " . _hx_string_or_null($path) . " with extensions ";
			$testNextExtension2 = _hx_string_or_null($testNextExtension1) . Std::string($templatingEngine->extensions);
			$testNextExtension3 = tink_core_Outcome::Failure(new tink_core_TypedError(null, $testNextExtension2, _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 131, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
			$tplStrReady->trigger($testNextExtension3);
		}
	}
}
function ufront_view_UFViewEngine_2(&$_gthis, &$ext, &$finalPath, &$path, &$templatingEngine, &$testNextEngine, &$tplEngines, &$tplStrReady) {
	{
		if($tplEngines->length > 0) {
			$engine = $tplEngines->shift();
			if(Lambda::has($engine->extensions, $ext)) {
				$finalPath = haxe_io_Path::normalize($path);
				$_gthis->getTemplateString($finalPath)->handle(array(new _hx_lambda(array(&$engine, &$path, &$templatingEngine, &$tplStrReady), "ufront_view_UFViewEngine_6"), 'execute'));
			} else {
				call_user_func($testNextEngine);
			}
		} else {
			$testNextEngine2 = tink_core_Outcome::Failure(new tink_core_TypedError(null, "No templating engine found for " . _hx_string_or_null($path) . " (None support extension " . _hx_string_or_null($ext) . ")", _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 151, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
			$tplStrReady->trigger($testNextEngine2);
		}
	}
}
function ufront_view_UFViewEngine_3(&$_gthis, &$engine1, &$ext2, &$extensions, &$extensionsUsed, &$finalPath, &$path, &$templatingEngine, &$testNextEngineOrExtension, &$tplEngines1, &$tplStrReady) {
	{
		$testNextEngineOrExtension1 = null;
		if($extensions->length === 0) {
			$testNextEngineOrExtension1 = $tplEngines1->length === 0;
		} else {
			$testNextEngineOrExtension1 = false;
		}
		if($testNextEngineOrExtension1) {
			$testNextEngineOrExtension2 = "No template found for " . _hx_string_or_null($path) . " with extensions ";
			$testNextEngineOrExtension3 = _hx_string_or_null($testNextEngineOrExtension2) . Std::string($extensionsUsed);
			$testNextEngineOrExtension4 = tink_core_Outcome::Failure(new tink_core_TypedError(null, $testNextEngineOrExtension3, _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 165, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
			$tplStrReady->trigger($testNextEngineOrExtension4);
			return;
		} else {
			if($extensions->length === 0) {
				$engine1 = $tplEngines1->shift();
				$extensions = $engine1->extensions->copy();
				$ext2 = $extensions->shift();
			} else {
				$ext2 = $extensions->shift();
			}
		}
		$extensionsUsed->push($ext2);
		$finalPath = haxe_io_Path::withExtension($path, $ext2);
		$_gthis->getTemplateString($finalPath)->handle(array(new _hx_lambda(array(&$engine1, &$templatingEngine, &$testNextEngineOrExtension, &$tplStrReady), "ufront_view_UFViewEngine_7"), 'execute'));
		return;
	}
}
function ufront_view_UFViewEngine_4(&$_gthis, &$finalPath, &$path, &$templatingEngine, $tplStr) {
	{
		try {
			$tpl4 = $templatingEngine->factory($tplStr);
			if($_gthis->cache !== null) {
				$this1 = $_gthis->cache;
				$this2 = new tink_core_MPair($templatingEngine->type, $tpl4);
				$v = $this2;
				$this1->set($path, $v);
			}
			return tink_core_Outcome::Success($tpl4);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				return tink_core_Outcome::Failure(tink_core_TypedError::withData(null, "Failed to parse template " . _hx_string_or_null($finalPath) . " using " . _hx_string_or_null($templatingEngine->type), $e, _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 205, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
			}
		}
	}
}
function ufront_view_UFViewEngine_5(&$testNextExtension, &$tplStrReady, $result1) {
	{
		switch($result1->index) {
		case 0:{
			switch(_hx_deref($result1)->params[0]->index) {
			case 0:{
				$tpl1 = _hx_deref(_hx_deref($result1)->params[0])->params[0];
				$tplStrReady->trigger(tink_core_Outcome::Success($tpl1));
			}break;
			case 1:{
				call_user_func($testNextExtension);
			}break;
			}
		}break;
		case 1:{
			$err1 = _hx_deref($result1)->params[0];
			$tplStrReady->trigger(tink_core_Outcome::Failure($err1));
		}break;
		}
	}
}
function ufront_view_UFViewEngine_6(&$engine, &$path, &$templatingEngine, &$tplStrReady, $result2) {
	{
		switch($result2->index) {
		case 0:{
			switch(_hx_deref($result2)->params[0]->index) {
			case 0:{
				$tpl2 = _hx_deref(_hx_deref($result2)->params[0])->params[0];
				{
					$templatingEngine = $engine;
					$tplStrReady->trigger(tink_core_Outcome::Success($tpl2));
				}
			}break;
			case 1:{
				$testNextEngine1 = tink_core_Outcome::Failure(new tink_core_TypedError(null, "Template " . _hx_string_or_null($path) . " not found", _hx_anonymous(array("fileName" => "UFViewEngine.hx", "lineNumber" => 147, "className" => "ufront.view.UFViewEngine", "methodName" => "getTemplate"))));
				$tplStrReady->trigger($testNextEngine1);
			}break;
			}
		}break;
		case 1:{
			$err2 = _hx_deref($result2)->params[0];
			$tplStrReady->trigger(tink_core_Outcome::Failure($err2));
		}break;
		}
	}
}
function ufront_view_UFViewEngine_7(&$engine1, &$templatingEngine, &$testNextEngineOrExtension, &$tplStrReady, $result3) {
	{
		switch($result3->index) {
		case 0:{
			switch(_hx_deref($result3)->params[0]->index) {
			case 0:{
				$tpl3 = _hx_deref(_hx_deref($result3)->params[0])->params[0];
				{
					$templatingEngine = $engine1;
					$tplStrReady->trigger(tink_core_Outcome::Success($tpl3));
				}
			}break;
			case 1:{
				call_user_func($testNextEngineOrExtension);
			}break;
			}
		}break;
		case 1:{
			$err3 = _hx_deref($result3)->params[0];
			$tplStrReady->trigger(tink_core_Outcome::Failure($err3));
		}break;
		}
	}
}
